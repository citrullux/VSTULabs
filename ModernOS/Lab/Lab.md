# Использование системных инструментов и языка высокого уровня

__Задание завершено и готово к выполнению__

Задания в данной работе идут между текстом глав для лучшего понимания контекста приводимой теоретической базы. Они помечаются следующим образом:

#### № Задание
---

В отчёте по лабораторной работе нужно прикладывать номера заданий в ходе работы.

## Введение

С момента основания компьютерной индустрии под взаимодействием пользователей с электронно вычислительной машиной (далее ЭВМ) понимается использование устройств предназначенных для __ввода__ с целью получения от неё какого либо результата  через соответствующие устройства __вывода__.

Если говорить более простым языком:

> Пользователь что-то подаёт ЭВМ ожидая какой-либо реакции на свои действия

Давайте рассмотрим печать текста в текстовом редакторе Google Docs. Как пользователь мы ожидаем что каждый вводимый нами символ с клавиатуры будет отображаться в документе после его введения. При помощи мыши мы имеем возможность выделения частей текста для выполнения иных действий, таких как выделения текста __жирным__, _курсивом_ или добавление <font color="#AAAAFF">иных</font> элементов и эффектов на страницу. При этом результат наших действий мы оцениваем при помощи экрана.

Данное описание применимо буквально для любого класса устройств, будь то наиболее распространённый вид ЭВМ на планете на момент написания этого материала, смартфон, а также любой другой вид ЭВМ, включая такие малораспространённые устройства как VR шлемы. Разница состоит в том, что на смартфоне в качестве "мыши" будет использоваться ввод через сенсорный экран, а в VR шлеме мы можем использовать контроллеры или собственные руки, которые современные шлемы умеют обнаруживать и использовать в работе.

Клавиатура и экран как концепция в современных устройствах есть буквально везде. Однако, существуют устройства у которых их нет. Как правило мы взаимодействуем с ними посредством ЭВМ у которых устройства ввода имеются. Если у вас когда-либо был __робот пылесос__, то скорее всего вы управляли им через ноутбук или смартфон у которых есть экран и клавиатура.

В экзотических сценариях в дополнение к уже перечисленным средствам могут использоваться иные устройства ввода, к примеру, мало кто использует клавиатуру для управления игрушечной машинкой, куда проще и точнее для этого использовать какой-либо контроллер.

> И на очередном абзаце этой стены текста возникает закономерный вопрос - __а при чём тут вообще курс _операционных систем_-то?__

## Глава 1 - Ввод/Вывод

Для начала нам потребуется ответить на простой вопрос - когда мы вводим что-то с клавиатуры, мыши или нажимаем на сенсорный экран мы взаимодействуем с операционной системой?

Наиболее распространённый ответ на этот вопрос у студентов - ну конечно-же __да__, ведь вот на экране __операционная система(ОС)__. Это может быть  Linux, Windows, macOS, Android, iOS _и дальше можно перечислять_, разве взаимодействие с ОС через экран, клавиатуру и другие устройства ввода не значит само по себе взаимодействие с ОС?

Такой ответ выглядит крайне логично. Но здесь необходимо привести пример, который объяснит, почему ответ не до конца верный.

__Вернёмся к первой аналогии__

Когда мы используем Google Docs чтобы редактировать документ, чем принципиально для нас, как пользователя, отличается взаимодействие с Google Docs на Windows, Linux, macOS и даже на Android и iOS?

> Мы везде используем __клавиатуру__, и некое __устройство ввода нажатий__ на область экрана чтобы редактировать текст и добавлять или удалять со страницы элементы.

И получается, что принципиальной разницы от изменения операционной системы мы как пользователь не получаем.

Ведь мы как пользователь работаем не с операционной системой, а с конкретным приложением, скорее всего Google Docs у вас открыт в браузере, который открыт на рабочем столе. И даже рабочий стол может быть разным, где-то как в Windows это будет __explorer.exe__, в Linux мы будем иметь дело с вариантами X-org/Wayland сессии, в MacOS и iOS за это будут отвечать другие приложения.

Выходит, что даже рабочий стол является приложением для отображения других приложений. В Linux если завершить рабочий стол как процесс, можно попасть в консоль из под которой рабочий стол был запущен, если он не будет автоматически перезапущен.

<blockquote>

Также, если нажать на сочетание клавиш `Ctrl+Alt+F2` в Linux вы попадёте во 2 консоль уйдя с рабочего стола, так как обычно помимо консоли, в которой отображается рабочий стол работает ещё 6 других консолей на случай зависания рабочего стола в основной консоли. Обычно сам рабочий стол работает в консоли под номером 7 или 1, чтобы на него перейти нужно нажать на `Ctrl+Alt+F1` либо `Ctrl+Alt+F1` соответственно

</blockquote>

Так что же такое __операционная система__ и __что конкретно__ она __делает?__

## Глава 2 - Идём от запуска

Вы никогда не задумывались что вообще происходит когда мы запускаем компьютер? Я не говорю о инициализации устройств, а также работе BIOS или UEFI. При помощи них управление передаётся загрузчику и начинает загружаться сама ОС.

Всё то время пока мы смотрим на красивое лого производителя данного компьютера если у нас UEFI или наслаждаемся красивым логотипом установленной операционной системы что-то происходит в фоне.

В целом администраторы которым нужно понимать что конкретно происходит с системой во время загрузки, либо смотрят в журнал ОС если она вообще запускается, либо включают отображение дампа загрузки вместо красивого графического отображения операционной системы.

В случае закрытых операционных систем мы точно не знаем что конкретно они делают, но в случае с Linux всё довольно очевидно.

> В глубину мы тут не полезем ибо оно особо не нужно нам на этом курсе...

Для понимание дальнейшего описания нужно понимать простую концепцию

__Linux__ это __не операционная система__.

__Linux__ это __ядро__. Вокруг которого операционная система может быть построена.

<blockquote>

Вы наверняка слышали про Android. В основе Android лежит ядро Linux, только вот весь софт который ядро окружает и конкретная Java машина сделаны или лицензированы компанией Google.

Существуют и другие оболочки, Ubuntu, Red Hat, GNU и прочее. Разница между этими операционными системами состоит в тех приложениях, которые доступны по умолчанию и особенностях взаимодействия с конкретной операционной системой.

Обычно системы на Linux в профессиональной среде называются как __Android/Linux__ __Ubuntu/Linux__ и __GNU/Linux__.

Кстати, если бы Windows именовалась схожим образом то она должна была бы называться __Windows98/DOS__ __Windows11/NT__ а macOS - __MacOS/XNU__.

> Как можно заметить ядро Windows 98 и Windows 11 отличается. Если интересно почему так произошло, можете уточнить этот момент на отчёте.

</blockquote>


Задача __загрузки ОС__ по-сути состоит в __запуске приложения__ с которым будет __взаимодействовать__ пользователь.

Для того чтобы приложение, с которым пользователь хочет взаимодействовать, могло работать как надо, оно должно иметь возможность получать данные с ввода и передавать данные на вывод.

И в целом мысль состоит бы в том что надо просто дать приложению возможность взаимодействовать с вводом и выводом как оно захочет, и всё будет хорошо.

Но в данной концепции работы приложений заложена определённая __проблема__.

## Глава 3 - Интерфейс программирования приложения (API)

![DOOM Configuration](./Images/setup.png)

Рисунок 1 - Окно конфигурации звука DOS

Перед вами окно конфигурации звука для DOS версии игры Doom, и это прямой пример того, что случается, когда мы оставляем взаимодействие с чем-либо на программу вместо того чтобы работать посредством операционной системы.

Проблема, которую обозначает этот рисунок заключается в том, что для поддержки вывода звука из игры нужно всего-лишь написать собственную реализацию кода взаимодействия для каждой конкретной звуковой карты.

И если реализация для конкретной звуковой карты не была написана разработчиком, то с такой звуковой картой звука вы из Doom на DOS получить не могли.

И надо понимать, что если каждый разработчик должен будет самостоятельно реализовывать поддержку всего оборудования, то больше времени он будет уделять написанию кода поддержки, нежели созданию самого приложения.

Потому в операционной системе есть такая вещь как API. API является интерфейсом, предлагающим некоторые функции при помощи которых ваше приложение может взаимодействовать с определёнными приложениями и интерфейсами задача которых состоит в том, чтобы как-либо взаимодействовать с оборудованием.

Если вы когда-нибудь наблюдали на коробке видеокарты или любого другого оборудования что оно совместимо с DirectX или OpenGL/OpenAL или Vulkan то вы видели прямое указание возможности взаимодействия с этими устройствами посредством данных API.

Но в целом DOS тоже был операционной системой, которая обеспечивала некоторые взаимодействия без вмешательства программиста.

К примеру работа с диском(что очень актуально в системе, которая называется Disc Operating System), возможность выводить звук на PC-speaker и изображение на экран, взаимодействие с клавиатурой были заложены в операционную систему как готовые API.

![IBM PC](./Images/ibmpc.jpg)

Рисунок 2 - IBM PC

Такой набор возможностей во многом обусловлен тем, чем являлся IBM PC на начале своего пусти - простым домашним компьютером с монитором, клавиатурой и PC-спикером для вывода звука.

Подводя итоги:

>__Операционная система__ - это набор приложений и  ядро, задача которых состоит в предоставлении другим приложениям возможности работать с определённым оборудованием и взаимодействовать с другими приложениями и/или пользователем.

Если взять представленное определение - то работа с операционной системой с точки зрения как пользователя так и администратора состоит в использовании различных приложений в целях достижения определённых результатов.

И в целом, можно было бы прямо сейчас открыть Linux консоль и начать просто вводить какие-либо команды рассматривая что они делают, но это не так интересно. Нужно написать что-то интересное и нужное, но чтобы понимать что конкретно мы делаем и почему, нужно дать немного информации на примерах.

Давайте начнём с одной из основных концепций в Linux.

## Глава 4 - Работа с файловой системой

В целом довольно плохо начинать изучение файловой системы в Linux с приведения Windows в аналогию, но для большей понятности мы поступим именно так.

Да и возможно содержимое пункта 4.1 будет даже для вас некоторым новым материалом.

### 4.1 Понятный большинству подход и его "особенности"

Для тех кто работал с Windows и представляет файловую систему как что-то начинающееся с имени диска, к примеру, `C:` требуется понять что такая концепция характерна __только__ для Windows.

В Windows мы можем перейти с диска `C:` на диск `D:` просто вписав в консоль `D:` и если у нас есть диск с такой буквой, консоль переключится на другой диск.

![Drive switch](./Images/switch.png)

Рисунок 3 - Пример смены диска

Также переходя в диспетчер файлов в левой части окна мы можем видеть список наших дисков, что очень удобно. И те, кто пользовался Windows примерно всегда знают что а диске `C:` можно найти папки Windows, Program Files и Users, а остальное будет опционально.

Неизменным остаётся только один факт - все папки внутри диска `C:` должны находиться на __одном__  физическом диске ну или на массиве дисков объединённых в __один__ если мы имеем дело с RAID.

> Однако то что написано в прошлом абзаце - __неправда__

Механизм Windows действительно подразумевает создание нового диска при попытке подключения нового раздела или диска, однако если пойти в инструмент __управление компьютером__ и перейти в __управление дисками__ можно немного удивиться.

![Connect as folder](./Images/connect.png)

Рисунок 4 - Подключение диска как папки.

Да, можно просто подключить диск как папку на другом диске, и это даже будет работать. Однако изначальная папка, куда мы хотим смонтировать наш диск должна быть пустой.

А для Linux такой механизм взаимодействия является __базовым__.

### 4.2 Файловая система в Linux. Основы

__"Всё есть файл."__ - это основная концепция ОС на базе ядра Linux.

В Linux со любым ресурсом который у вас есть можно взаимодействовать как с файлом, в том числе с устройствами.

В Linux всё начинается с корня - `/`

Корневая файловая система в Linux содержит в себе все файлы операционной системы, из корня можно перейти в каждую директорию и файл.

В базовой комплектации в директории `/` содержатся следующие поддиректории:

```
/bin /dev /home /media /proc /sbin /sys /var /boot /etc /lib /mnt /root /tmp /lib64 /opt /run /usr
```

Если в Windows чтобы посмотреть на имеющиеся устройства мы должны пойти в диспетчер устройств, то в Linux можно просто перейти в директорию `/dev` и увидеть все устройства которые система обнаружила в виде файлов.

Из этих файлов можно считывать информацию, а также можно попытаться в них что-то записывать.

> Автор данного материала крайне __не рекомендует__ что-либо записывать в файлы устройств, все возможные наносимые __повреждения__ операционной системе от использования _sudo_ или _root_ в результате таких действий остаются на __ответственности пользователя__.

В пункте 4.1 я приводил некоторые папки Windows, их очень примерными аналогами в Linux являются:

`C:/Users -> /home`

```
C:/ProgramFiles ->
/bin /sbin
/usr/bin /usr/sbin
/opt
```

`C:/Windows -> /sys`

Но всё это очень примерно, так как подходы операционных систем отличаются, и значимо. Это скорее приведено чтобы знать где примерно искать.

В Linux каждая из этих директорий находящихся в `/`, будь то `/home`, `/bin`, `/boot` или любая другая может представлять из себя совершенно другой диск, который смонтирован как папка.

Получается что всё что находится в конкретной директории (включая вложенные директории) будет располагаться на другом диске если директория туда смонтирована. Но также любая из вложенных директорий может быть смонтирована на третий диск и.т.д.

### 4.3 Файловая система в Linux. Домашняя директория

Когда в Linux мы как пользователь открываем терминал перед нами обычно предстаёт консоль которая выдаёт нам имя нашего пользователя, название компьютера, текущий путь и текущие права.

В случае автора материала это обычно выглядит так:

`citrullux@Zenphyrus:~$`

Здесь:

`citrullux` - имя пользователя

`Zenphyrus` - название компьютера

`~` - указание на домашнюю директорию

`$` - текущие права, обычный пользователь , права суперпользователя выглядят так: `#`

Сейчас нас интересует домашняя директория.

Когда пользователь создаётся в системе, обычно ему присваивается некоторая директория, все файлы в которой будут принадлежать ему, _если не сказано обратное_.

Обычно домашняя директория пользователя находится по пути `/home/имя_пользователя/` и переход в неё приводит обозначение текущей директории к `~`.

#### 4.3.1 Задание
---

Давайте посмотрим на некоторые базовые вещи в работе файловой системы.

Откроем Visual Studio Code и подключимся к WSL (если вы в Windows10/11 с установленным WSL 2) и откроем домашнюю директорию:

`(Open Folder) -> /home/имя_пользователя`.

![Open Folder](./Images/directory.png)

Рисунок 5 - Открытие директории

После открытия директории нажмите около её названия на кнопку `New Folder` и создайте директорию с названием `ProjectOS` или назовите по своему желанию.

Теперь откроем созданную нами директорию проекта

`(Open Folder) -> /home/имя_пользователя/ProjectOS/`

И потяните за нижнюю часть окна Visual Studio Code чтобы открыть терминал как показано на рисунке 6.

![Project and Terminal](./Images/project.png)

Рисунок 6 - Открытая директория с проектом.

Обычно терминал должен открыться сразу в нужном расположении: `~/ProjectOS/`, если этого не произошло, в терминале выполните команду `$ cd ~/ProjectOS/`

Команда `cd` предназначена для перехода из директорию в другую директорию.

Создадим в директории новый файл `main.sh`

Можно сделать это из интерфейса VSCode `(New File)`

Либо используя терминал `$ touch main.sh`

Давайте попробуем некоторые команды в терминале

`$ uname -a` - Покажет версию ядра системы и всю информацию о нём

`$ date > when` - Узнает текущую дату и время и запишет в файл `when`, тут `>` - это указание на запись результата операции в определённый файл.

Можно открыть файл `when` и посмотреть на данные внутри файла.

Откроем файл `main.sh` в VSCode и запишем в него следующее:
```
#!/bin/bash

uname -a > ./when
date >> ./when
```
Это скрипт, который используя среду исполнения /bin/bash выполняет 2 терминальных команды.

Выполним его в терминале при помощи:

`$ sh main.sh`

После завершения выполнения можно просмотреть файл `when` и увидеть его содержимое. не забудьте привести содержимое файла в вашем отчёте.

![Файл when](./Images/when.png)
Рисунок 7 - Просмотр содержимого файлов

Отличие `>` от `>>` состоит в том, что первый оператор полностью перезаписывает файл новыми данными, а второй добавляет в уже существующий файл ещё одну строку.

Потому мы получили в одном файле версию ядра и текущее время.

Теперь перейдём к созданию директорий

Изменим `main.sh`:
```
#!/bin/bash

mkdir -p scripts
mkdir -p outputs

ls -lai . > ./outputs/dirstat

mv when ./outputs/when
mv main.sh ./scripts/main.sh
```
Выполнив текущую версию скрипта мы получим созданные папки командами `mkdir`.

Скрипт `main.sh` станет недоступным после исполнения. Надо будет закрыть отсутствующий файл в VSCode и открыть его по пути `scripts/main.sh`.

Команда `mv` перемещает файл в другую директорию.

Изменим `main.sh` ещё раз.
```
#!/bin/bash

ls -lai ../scripts >> ../outputs/dirstat
```
И попробуем запустить из консоли `$ sh scripts/main.sh`

<blockquote>

И да, вывод этой команды будет ошибочным:

`ls: cannot access '../scripts/': No such file or directory`

</blockquote>

Проблема в том, что __мы__ запускаем скрипт из директории, в которой путь `../scripts` не существует.

То есть, если попробовать выполнить `cd ../scripts` в терминале - то ничего не сработает.

Потому перепишем файл `main.sh` следующим образом:
```
#!/bin/bash
SCRIPT=$(readlink -f "$0")
DIR=$(dirname "$SCRIPT")

cd $DIR
ls -lai ../scripts >> ../outputs/dirstat
```
И запустим `$ sh scripts/main.sh`

Итак, мы имеем на текущий момент проект в Visual Studio Code в котором есть один файл кода на языке shell в каталоге `scripts`, и 2 файла простого текста в каталоге `outputs`.

А теперь, после всех этих пунктов вернёмся к теории.

### 4.4 Файловая система в Linux. А что вообще такое файл?

Если взглянуть в финальный файл `dirstat`, который располагается в директории `outputs` то можно в нём увидеть содержание схожее с текущим.
```
total 24
97240 drwxr-xr-x  4 citrullux citrullux 4096 Oct 29 17:55 .
477 drwxr-x--- 30 citrullux citrullux 4096 Oct 28 17:50 ..
97252 -rw-r--r--  1 citrullux citrullux  130 Oct 29 17:55 main.sh
27342 drwxr-xr-x  2 citrullux citrullux 4096 Oct 29 17:55 outputs
27339 drwxr-xr-x  2 citrullux citrullux 4096 Oct 29 17:55 scripts
97283 -rw-r--r--  1 citrullux citrullux  150 Oct 25 14:15 when

total 12
27339 drwxr-xr-x 2 citrullux citrullux 4096 Oct 29 17:55 .
97240 drwxr-xr-x 4 citrullux citrullux 4096 Oct 29 17:55 ..
97252 -rw-r--r-- 1 citrullux citrullux  113 Oct 29 18:08 main.sh
```
Давайте внимательно рассмотрим содержимое.

---

Команда с флагом `-lai` подразумевает отображение всех файлов в текущей директории с отображением индексов файлов.

В первой команде `$ ls -lai`

Файл `main.sh` отображался следующим образом:

`97252 -rw-r--r--  1 citrullux citrullux  130 Oct 29 17:55 main.sh`

После переноса в другую директорию он выглядит так:

`97252 -rw-r--r-- 1 citrullux citrullux  113 Oct 29 18:08 main.sh`

Первое значение - это индекс файла.

В моём варианте значение равно `97252` для обоих файлов.

Структура файлов, в которой файлы вложены в директории, является __красивым представлением__ для пользователя, с точки зрения операционной системы файлы просто находятся на смонтированном диске и им __присвоен какой-либо номер__ начиная с 1.

Файл является одним и тем же с точки зрения системы, __перенос__ командой `mv` из директории в директорию __не приводит__ к изменению файла на диске.

При __копировании__ файла командой `cp` будет создан __новый файл__ на диске и им будет получен __новый индекс__.

### 4.5 Файловая система в Linux. Директории

Среди обычных файлов в команде `ls -lai` отдельно стоит обсудить обозначения нестандартных файлов.

Поскольку в Linux всё есть файл, то директория и ссылка и даже устройства, это тоже файлы.

Команда `ls -lai` отображает тип файла на отмеченной позиции.

27339 <font color="#FF5555">__d__</font>rwxr-xr-x  2 citrullux citrullux 4096 Oct 29 17:55 scripts

Значения данного показателя могут быть следующими:
```
- Обычные файлы
d Каталоги
l Символьные ссылки
b Блочные устройства
c Символьные устройства
p Каналы
s Сокеты
```
И в данном случае `scripts` - это директория.

Директория `scripts` вложена в директорию `ProjectOS`.

В любой директории всегда есть 2 файла
`.` и `..`

Внутри директории `scripts` данные файлы выглядят следующим образом:
```
27339 drwxr-xr-x 2 citrullux citrullux 4096 Oct 29 17:55 .
97240 drwxr-xr-x 4 citrullux citrullux 4096 Oct 29 17:55 ..
```
Эти 2 файла являются директориями.

А теперь рассмотрим директорию `ProjectOS`.
```
total 24
97240 drwxr-xr-x  4 citrullux citrullux 4096 Oct 29 17:55 .
477 drwxr-x--- 30 citrullux citrullux 4096 Oct 28 17:50 ..
27339 drwxr-xr-x  2 citrullux citrullux 4096 Oct 29 17:55 scripts
```
В данном выводе мы видим, что директория `scripts` имеет индекс `27339`. А в самой директории `scripts` файл `.` имеет ровно такой-же индекс `27339`.

Это значит что команда `$ cd scripts` выполненная в директории `ProjectOS` и команда `cd .` выполненная из директории `scripts` приведут к переходу в директорию `scripts`.

То есть файл `.` в составе директории указывает на саму директорию.

Файл `..` в директории scripts выглядит следующим образом:

`97240 drwxr-xr-x 4 citrullux citrullux 4096 Oct 29 17:55 ..`

И индекс этого файла совпадает с индексом файла `.` в директории `ProjectOS`

`97240 drwxr-xr-x  4 citrullux citrullux 4096 Oct 29 17:55 .`

То есть выполнение `cd ..` из любой директории приведёт к переходу на директорию выше.

Помимо этих файлов в директории находится информация о индексах файлов для которых текущая директория является __"местоположением"__.

Примерно так и работают директории.

### 4.6 Файловая система в Linux. Ссылки, жёсткие и мягкие

В Linux есть система мягкий и жёстких ссылок.

Если вы когда-либо работали со ссылками в Windows, то вы примерно представляете что из себя представляет мягкая ссылка: это просто указание точного пути до файла, к которому нужно обратиться при обращении любого приложения к ссылке.

Жёсткая ссылка - это и есть сам файл. И сразу это не так очевидно.

#### 4.6.1 Задание

Давайте вернёмся в наш редактор и продолжим изменять файл `main.sh`
```
#!/bin/bash
SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта

# Создаём директорию и переходим в неё
mkdir -p data
cd data
echo "Hello world!" > world # Создаём файл с названием world
ln -f world flat # Создаём жёсткую ссылку
ln -s -f world globe # Создаём мягкую ссылку

# Читаем содержимое файлов в файл links
cat world > ../outputs/links
cat flat >> ../outputs/links
cat globe >> ../outputs/links
# Просматриваем состав директории
ls -lai >> ../outputs/links
```
Сохраним и исполним файл `$ sh scripts/main.sh`

Теперь изменим файл `main.sh` следующим образом:
```
#!/bin/bash
SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта
cd data

echo "Place where human lives" > world # Изменяем данные в файле world

# Читаем содержимое файлов в файл links
cat world >> ../outputs/links
cat flat >> ../outputs/links
cat globe >> ../outputs/links

echo "Is this flat?" > flat # Изменяем данные в файле flat

# Читаем содержимое файлов в файл links
cat world >> ../outputs/links
cat flat >> ../outputs/links
cat globe >> ../outputs/links

echo "Think different" > globe # Изменяем данные в файле globe

# Читаем содержимое файлов в файл links
cat world >> ../outputs/links
cat flat >> ../outputs/links
cat globe >> ../outputs/links
```
Сохраним и исполним файл `$ sh scripts/main.sh`

Изменим файл `main.sh`
```
#!/bin/bash
SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта
cd data

echo "Ready to destroy" > world # Изменяем данные в файле world
rm world # Удаляем файл
cat flat >> ../outputs/links
cat globe >> ../outputs/links

# Просматриваем состав директории
ls -lai >> ../outputs/links
```
Сохраним и исполним файл `$ sh scripts/main.sh`

Скорее всего в результате выполнения будет выдана ошибка:
`cat: globe: No such file or directory`

Изменим файл `main.sh` в последний раз в текущем блоке.
```
#!/bin/bash
SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта
cd data

echo "This is another world" > world # Создаём новый файл world

# Читаем содержимое файлов в файл links
cat world >> ../outputs/links
cat flat >> ../outputs/links
cat globe >> ../outputs/links

# Просматриваем состав директории
ls -lai >> ../outputs/links
```
Сохраним и исполним файл `$ sh scripts/main.sh`

#### Разбор задания
---

Откройте в директории `data` файл `links`.

По результатам выполнения задания, в файле находятся следующие строки:
```
Hello world!
Hello world!
Hello world!
```
Первые 3 строки содержат в себе надпись "Hello world!". Это результат выполнения команд:
```
cat world > ../outputs/links
cat flat >> ../outputs/links
cat globe >> ../outputs/links
```
Которые считывают данные из 3 файлов, world, flat и globe, далее обозначена выдача команды `ls -lai` в которой нас интересуют следующие строки:
```
28332 -rw-r--r-- 2 citrullux citrullux   13 Nov  1 16:11 flat
35272 lrwxrwxrwx 1 citrullux citrullux    5 Nov  1 16:11 globe -> world
28332 -rw-r--r-- 2 citrullux citrullux   13 Nov  1 16:11 world
```
Как можно понять файлы `world` и `flat` это один и тот же файл, поскольку индекс `28332` __совпадает__ для __обоих файлов__, и да, у вас этот индекс _скорее всего_ для обоих файлов будет также __одинаковым__, но другим.

С другой стороны файл `globe` представляет из себя мягкую ссылку, у него иной индекс. А сам файл в `ls -lai` имеет тип `l` и обозначается как `globe -> world`, то есть файл `globe` ссылается на файл `world`, пока файл `world` продолжает существовать.

35272 <font color="#FF5555">l</font>rwxrwxrwx 1 citrullux citrullux    5 Nov  1 16:11 <font color="#FF5555">__globe -> world__</font>

Мягкая _символьная_ ссылка создаётся командой `ln -s имя_файла имя_ссылки`.

Жёсткая ссылка создаётся командой `ln имя_файла имя_ссылки`

Флаг `-f` был добавлен в обоих случаях для того чтобы ссылка была пересоздана, в том случае, если она существует. Если флаг не был установлен, в консоль была бы выдана ошибка при повторном исполнении скрипта `main.sh`.

Команда `ls -lai` отображает количество жёстких ссылок на файл на отмеченной позиции.

28332 -rw-r--r-- <font color="#FF5555">__2__</font> citrullux citrullux   13 Nov  1 16:11 world

28332 -rw-r--r-- <font color="#FF5555">__2__</font> citrullux citrullux   13 Nov  1 16:11 flat

И как можно увидеть для файла `world` и файла `flat` количество ссылок равно 2. А по факту оба файла представляют из себя файл `28332` расположенный на диске. Кстати можно обратить внимание что время последнего изменения написанное для обоих файлов совпадает.

В ОС на базе ядра Linux любой файл окончательно удаляется с диска в тот момент, когда на него не остаётся ни одной жёсткой ссылки, то есть пользователь никак не сможет получить доступ к этому файлу.

Механизм жёстких ссылок предназначается для __представления__ различных __файлов__ для конечного __пользователя__ в виде некоторой привычной структуры директорий и файлов вложенных в них.

Далее в файле `links` находятся следующие строки:
```
Place where human lives
Place where human lives
Place where human lives
```
Этот блок строк получен в результате выполнения следующего кода:

`echo "Place where human lives" > world`

и считывания данных из файлов `world` `flat` и `globe`
```
Is this flat?
Is this flat?
Is this flat?
```
Полученный в результате выполнения:

`echo "Is this flat?" > flat`
```
Think different
Think different
Think different
```
В результате `echo "Think different" > globe` соответственно.

После удаления файла `world` получаем в выдаче только
```
Ready to destroy
```
И ошибку чтения файла `globe`, так как он ни на что не указывает после удаления файла `world`

Стоит также отметить что число жёстких ссылок на файл `flat` стало равным 1 после удаления файла world.
```
28332 -rw-r--r-- 1 citrullux citrullux   17 Nov  1 17:44 flat
35272 lrwxrwxrwx 1 citrullux citrullux    5 Nov  1 16:11 globe -> world
```
Последний скрипт создавал новый файл world, с новым содержанием.

В файле `links` имеем:
```
This is another world
Ready to destroy
This is another world
```
То есть содержимое файла `world` изменилось, и мягкая ссылка `globe` которая указывает на `world` теперь имеет то же самое содержимое. Содержимое файла `flat` как и его индекс не изменилось.
```
28332 -rw-r--r-- 1 citrullux citrullux   17 Nov  1 17:44 flat
35272 lrwxrwxrwx 1 citrullux citrullux    5 Nov  1 16:11 globe -> world
28698 -rw-r--r-- 1 citrullux citrullux   22 Nov  2 09:40 world
```
Как можно видеть индексы файлов `world` и `flat` отличаются, это разные файлы, изменения в одном из них не создают изменения в другом.

### 4.7 Файловая система в Linux. Права доступа

В Linux есть 3 вида прав пользователя на файл.

У файла есть __владелец__, __группа владельца__ и __все остальные пользователи__ которые не входят ни в одну из представленных категорий.

__Владелец__ - это __конкретный пользователь__, а __группа владельца__ - это все __пользователи__ входящие в определённую __группу__.

Давайте взглянем на результат команды `ls -lai`
```
28698 -rw-r--r-- 1 citrullux citrullux   22 Nov  2 09:40 world
```
Давайте распределим по цвету. Тут представлены права для <font color="#FF5555">__владельца__</font>, <font color="#55FF55">___группы___</font> и <font color="#5555FF">_всех остальных_</font>.

1280 -
<font color="#FF5555">__rwx__</font>
<font color="#55FF55">___rw-___</font>
<font color="#5555FF">_r--_</font>
1
<font color="#FF5555">__citrullux__</font>
<font color="#55FF55">___citrullux___</font>
19 Sep  11 08:46 skyscraper

Давайте рассмотрим формулировку `rwx`, у неё есть 8 вариантов и 8 соответствущих представлений в десятичном коде для команды `chmod`:

```
0: --- : Прав нет
1: --x : Есть права на исполнение
2: -w- : Есть права на запись в файл
3: -wx : Есть права на запись в файл и его исполнение
4: r-- : Есть права на чтение файла
5: r-x : Есть права на чтение файла и его исполнение
6: rw- : Есть права на чтение файла и запись в файл
7: rwx : Есть права на чтение файла, запись в файл и его исполнение
```

И тут может возникнуть интересная мысль у тех, кто уже смотрел в выдачу файла `main.sh` в команде `ls -lai`, напомню, она выглядит следующим образом:

`97252 -rw-r--r--  1 citrullux citrullux  130 Oct 29 17:55 main.sh`

Прав на исполнение этого файла вроде как и нет, но мы его вроде как исполняем при помощи команды `sh main.sh`.

И дело как раз таки в том, что мы его исполняем именно этим образом, мы выполняем не сам файл `main.sh` а команду `sh`, и если сделать в консоли `which sh` то мы получим:

`/usr/bin/sh`

Или что-то вроде такого, если дальше исполнить команду `ls -lai /usr/bin/sh` то можно получить то, чем является сам `sh`.

`1801 lrwxrwxrwx 1 root root 4 Nov 23  2023 /usr/bin/sh -> dash`

Как мы уже знаем, если на позиции типа файла находится символ `l` мы имеем дело с символьной ссылкой, которая не отображает свойств самого файла. Потому изменим команду на `ls -lai /usr/bin/dash`. Используем название файла `dash` так как ссылка указывает на него.

`1357 -rwxr-xr-x 1 root root 125688 Mar 23  2022 /usr/bin/dash`

Из этого следует, что файл `sh` принадлежит пользователю `root` и группе `root`. Но для всех пользователей операционной системы файл доступен на чтение и исполнение, что приводит к тому, что `sh` можно исполнить, а приложение `sh` само выполнит написанный вами файл как захочет, так как права на чтение файла `main.sh` у вас есть.

#### 4.7.1 Задание
---
Давайте рассмотрим работу с правами на нескольких примерах.

Изменим файл `main.sh`
```
#!/bin/bash

SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта
cd data

# Изменяем права
chmod 777 flat
chmod 300 world

# Записываем данные
echo "This is not a planet?" > world

# Пытаемся считывать данные
cat flat > ../outputs/links
cat world >> ../outputs/links

# Вывод содержимого директорий
ls -lai >> ../outputs/links
```
Сохраним и исполним файл `$ sh scripts/main.sh`

Выполнение выведет ошибку:

`cat: world: Permission denied`

Изменим файл `main.sh`

```
#!/bin/bash

SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта

# Добавляем право на исполнение для main.sh
chmod +x scripts/main.sh

cd data

# Изменяем права
chmod 070 flat
chmod 400 world

# Записываем данные
echo "How much time in eternity?" > world
echo "One eternity later" > flat

# Пытаемся считывать данные
cat flat >> ../outputs/links
cat world >> ../outputs/links

# Вывод содержимого директорий
ls -lai >> ../outputs/links
ls -lai ../scripts/ >> ../outputs/links
```
Сохраним и исполним файл `$ sh scripts/main.sh`

Выполнение выдаст ошибки:

`scripts/main.sh: 15: cannot create world: Permission denied`

`scripts/main.sh: 16: cannot create flat: Permission denied`

`cat: flat: Permission denied`

---

Для __дальнейшего выполнения__ данного практического блока __потребуются__ права <font color="#FF8822">уровня суперпользователя</font> чтобы использовать `sudo`

Или работать от пользователя `root` если вы любите уничтожать свою систему или понимаете что вы делаете.

Выполните в терминале команду:

`$ sudo echo "Hello"`

Вы получите запрос вашего пароля, если текущая настройка `/etc/sudoers` требует ввода пароля для использования прав `sudo` для вашего пользователя или группы, в которую он входит.

---

Изменим файл `main.sh`
```
#!/bin/bash

SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта
cd data

# Изменяем владельцев файлов
chown root:root flat
chown root:root world

# Изменяем права
chmod 007 flat
chmod 770 world

# Записываем данные
echo "How much continents?" > world
echo "We are number one, but..." > flat

# Пытаемся считывать данные
cat flat >> ../outputs/links
cat world >> ../outputs/links
cat globe >> ../outputs/links

# Вывод содержимого директорий
ls -lai >> ../outputs/links
```
И выполним скрипт, теперь без `sh`, так как с прошлого исполнения файл можно исполнять сам по себе.

`$ sudo ./scripts/main.sh`
```
#!/bin/bash

SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта
cd data

# Записываем данные
echo "Time to listen" > world
echo "The greatest show on earth" > flat

# Пытаемся считывать данные
cat flat >> ../outputs/links
cat world >> ../outputs/links
cat globe >> ../outputs/links

# Вывод содержимого директорий
ls -lai >> ../outputs/links
```
Давайте выполним без `sudo`

`$ ./scripts/main.sh`

И получим в консоли:

`./scripts/main.sh: line 11: world: Permission denied`

`cat: world: Permission denied`

`cat: globe: Permission denied`

#### Разбор задания
---
Откройте в директории `data` файл `links`.

Выдача первой стадии исполнения.
```
Ready to destroy
28332 -rwxrwxrwx 1 citrullux citrullux   17 Nov  1 17:44 flat
35272 lrwxrwxrwx 1 citrullux citrullux    5 Nov  1 16:11 globe -> world
28698 --wx------ 1 citrullux citrullux   22 Nov  8 09:22 world
```
Содержимое файла `flat` было выведено. Содержимое файла `world` было изменено на `This is not a planet?`, но вывести в файл содержимое не получилось, так как прав на чтение `r` у пользователя нет, есть только `wx`. Потому в консоль было выведено:

`cat: world: Permission denied`

Выдача второй стадии:
```
This is not a planet?
28332 ----rwx--- 1 citrullux citrullux   17 Nov  1 17:44 flat
35272 lrwxrwxrwx 1 citrullux citrullux    5 Nov  1 16:11 globe -> world
28698 -r-------- 1 citrullux citrullux   22 Nov  8 09:22 world
97252 -rwxr-xr-x 1 citrullux citrullux  756 Nov  8 10:09 main.sh
```
Теперь у файла `world` есть права на чтение, и мы смогли его прочитать. Но записать в него новые данные не получится. Файл `main.sh` получил возможность исполнения `x` посредством команды `chmod +x` то есть `+` это добавление, а `x` конкретное право, в данном случае исполнение, как можно понять право на исполнение было добавлено для всех уровней прав.

Файл `flat` для группы `citrullux` имеет все права, но ни записать ни считать данные от пользователя `citrullux` не получилось, по очень простой причине: права пользователя важнее прав группы. А права пользователя говорят что возможностей чтения и записи нет.

Выдача третей стадии:
```
We are number one, but...
How much continents?
How much continents?
28332 -------rwx 1 root      root        26 Nov 12 13:14 flat
35272 lrwxrwxrwx 1 citrullux citrullux    5 Nov  1 16:11 globe -> world
28698 -rwxrwx--- 1 root      root        21 Nov 12 13:14 world
```
Поскольку мы исполняем скрипт от `sudo`, мы смогли записать новое содержимое в файлы `world` и `flat`, не смотря на то что мы передали владение файлами пользователю `root` и группе `root`. Ошибок при исполнении на этой стадии не было.

Выдача четвёртой стадии:
```
The greatest show on earth
28332 -------rwx 1 root      root        27 Nov 12 13:22 flat
35272 lrwxrwxrwx 1 citrullux citrullux    5 Nov  1 16:11 globe -> world
28698 -rwxrwx--- 1 root      root        21 Nov 12 13:14 world
```
Тут мы смогли записать и прочитать содержимое только файла `flat`, так как наш пользователь не относится к пользователю `root` и не входит в группу `root`. Файл `globe` как ссылка в теории может быть прочитан нашим пользователем, но указывает он на файл `world`, который недоступен для обычного пользователя, так что содержимое ээтих файлов обычному пользователю недоступно.


## Глава 5 - Службы в Linux

Службы в Linux также называют __демонами__.

Если говорить максимально просто:

__Демон__ или __Служба__ - это __приложение запускаемое системой автоматически__ при старте системы или в определённый назначенный момент работы, которое в зависимости от настроек будет __перезапускаться__ само по себе __в случае падения или закрытия__.

К примеру, можно так открывать браузер, который при закрытии будет открываться заново.

_Или приложение на рабочий стол которая будет выдавать информацию на рабочий стол, притом права __администратора__ даже не понадобятся._

Если рассказывать __чуть сложнее__, то существует такая вещь как `systemd` и если обратиться к её мануалу то можно прочесть следующее.

<blockquote>

`systemd` - это системный менеджер и менеджер служб в ОС семейства Linux.

`systemd` обычно не запускается напрямую пользователем, но является символьной ссылкой для `init` процесса и стартует на ранних этапах запуска.

`systemd` предоставляет систему зависимостей между сущностями называющимися юнитами (`units`) 11 различных типов. Юниты включают в себя различные объекты, которые имеют отношение к загрузке и обслуживанию системы. Большинство юнитов настраиваются при помощи конфигурационных файлов юнитов, синтакс которых и основной набор опций описаны в другой части мануала (`systemd.unit(5)`), однако некоторые из них создаются автоматически из других файлов конфигурации, динамически из состояния системы или программно во время выполнения.

Юниты по состоянию могут быть активными `active` (started, bound, plugged in, и.т.д. в зависимости от типа юнита), или отключенным `inactive` (stopped, unbound, unplugged, и.т.д.), а также быть в процессе запуска или отключения, т.е.  между этими двумя состояниями (обозначаются как `activating` и `deactivating`).

Специальное состояние недачи `failed` также доступно, оно довольно схоже с состоянием "отключен" `inactive` в которое юнит входит когда сервис падает по какой-либо из причин (процесс вернул код ошибки завершая выполнение, или упал, или операция вышла за пределы время выполнения, или после большого числа перезапуска, заданного по умолчанию или пользователем в файле конфигурации).

Если юнит вошёл в состояние `failed` причина этого будет добавлена в логи для выяснения причин. Стоит учитывать что различные типы юнитов могут иметь дополнительные промежуточные состояния..

</blockquote>

### 5.1 Задание
---

Изменим файл `main.sh`
```
#!/bin/bash

SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта
rm -rf data/
rm -rf outputs/
```
И исполним от `sudo` в последний раз за лабораторную.

`$ sudo ./scripts/main.sh`

Что удалит из директории проекта все файлы кроме `main.sh` в директории `scripts`

> Для красоты можно выполнить в терминале команду `$ clear`

Создадим файл нашего первого сервиса. Изменим `main.sh` заданным содержимым.
```
#!/bin/bash

SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта

# Создание директорий локального systemd в домашней папке
mkdir -p  $HOME/.config
mkdir -p  $HOME/.config/systemd
mkdir -p  $HOME/.config/systemd/user

# Создание директории с файлами сервисов в папке проекта
mkdir services
cd services # И переход в неё

# Создание файла нашего первого сервиса
touch lab.service
ln -f lab.service $HOME/.config/systemd/user/lab.service
```
И выполним `$ ./scripts/main.sh`

Это создаст в папке проекта директорию `services` с файлом `lab.service` внутри.

Изменим файл `lab.service`:
```
[Unit]
Description=Lab first service

[Service]
Type=simple
ExecStart=sleep 40
Restart=on-failure

[Install]
WantedBy=default.target
```
И сохраним.

Изменяем `main.sh`
```
#!/bin/bash

SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта

# Создадим файл для сохранения состояний демона
mkdir -p data
cd data

touch daemon_state

# Обновления списка демонов доступных системе
systemctl --user daemon-reload

# Запуск написанного нами демона
systemctl --user start lab.service

# Считываем статус демона посреди работы
sleep 10
systemctl --user status lab.service >> daemon_state

# Считываем статус демона после завершения работы
sleep 45
systemctl --user status lab.service >> daemon_state
```
Выполняем `$ ./scripts/main.sh`

> Выполнение займёт примерно минуту, можно встать, походить по комнате, иногда это __стоит делать__ при сидячей работе.

В файле daemon_state наблюдаем примерно следующее:
```
● lab.service - Lab first service
     Loaded: loaded (/home/citrullux/.config/systemd/user/lab.service; disabled; vendor preset: enabled)
     Active: active (running) since Wed 2024-11-13 13:24:43 MSK; 10s ago
   Main PID: 60994 (sleep)
     CGroup: /user.slice/user-1000.slice/user@1000.service/app.slice/lab.service
             └─60994 sleep 40
```
На считывании спустя 10 секунд от запуска демон активен и выдаёт информацию в строке `Active` что работает уже 10 секунд: ` active (running) since * 10s ago`
```
○ lab.service - Lab first service
     Loaded: loaded (/home/citrullux/.config/systemd/user/lab.service; disabled; vendor preset: enabled)
     Active: inactive (dead)
```
На считывании спустя 55 секунд от запуска демон уже переведён в статус `inactive` и выдаёт информацию в строке `Active` что уже не работает: `inactive (dead)`

Изменим `lab.service`
```
[Unit]
Description=Lab first service

[Service]
Type=simple
Environment="DISPLAY=:0"
Environment="XAUTHORITY='/run/user/1000/gdm/Xauthority'"
ExecStart=remmina
Restart=always

[Install]
WantedBy=default.target
```

Изменим `main.sh`
```
#!/bin/bash

SCRIPT=$(readlink -f "$0") # Полный путь до скрипта
DIR=$(dirname "$SCRIPT") # Директория нахождения скрипта

cd $DIR # Переход в директорию скрипта
cd .. # Переход в директорию проекта

cd data

# Избавляемся от содержимого
cat /dev/null > daemon_state

# Обновления списка демонов доступных системе
systemctl --user daemon-reload

# Запуск написанного нами демона
systemctl --user start lab.service

# Считываем статус демона посреди работы
systemctl --user status lab.service >> daemon_state
```

Выполним: `$ ./scripts/main.sh`

И попробуйте закрыть открывшееся окно remmina `;)`

После того как приложение несколько раз перезапустится на попытке выйти из него, выполните в терминале:

`$ systemctl --user stop lab.service`

При помощи демонов мы создавали окно которое будет само по себе перезапускаться, это неплохо работает для всяких терминалов самообслуживания, где нужно просто пользователю дать интерфейс, который не отключится.

Удалим все файлы которые были сделаны:

`rm -rf ~/ProjectOS/*`

`rm -f ~/.config/systemd/user/lab.service`

## 6. Задание - Python, Bash и Systemctl

<blockquote>

В этом задании ожидается понимание принципов изложенных выше. Попробуйте сами разобраться в том что делают представленные далее команды `bash` скриптов так как общие принципы были изложены ранее и прокомментировать их в вашем коде сделав скриншоты и приложив их в отчёт.

</blockquote>

В директории проекта `ProjectOS` создадим через консоль:

`$ mkdir src`

`$ cd src`

`$ touch main.py`

`$ touch requirements.txt`

> Файл requirements.txt является списком элементов, которые должны быть установлены pip при использовании pip install. В этой части лабораторной он не понадобится, но лучше создавать его всегда заранее.

Запишем в `main.py`

```
from http.server import BaseHTTPRequestHandler, HTTPServer


def run(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler):
    server_address = ("", 7654)
    httpd = server_class(server_address, WeatherHandler)
    httpd.serve_forever()


class WeatherHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        return self.render(200, b"Hello World!")

    def render(self, response_code: int, response_body: bytes | None = None):
        self.send_response(response_code)
        if response_body is not None:
            self.send_header("Content-type", "text/html")
        self.end_headers()
        if response_body is not None:
            self.wfile.write(response_body)

run()
```

И запустим при помощи команды

`$ python3 main.py`

Чтобы увидеть результат выполнения данного кода откройте браузер и перейдите по адресу `localhost:7654`, рекомендую использовать для этого браузер Firefox с открытым окном анализа сети `F12 -> Сеть`.

Если на экране вы видите `Hello World!` а в статусе `200`, значит всё работает как надо. Также в терминале мы увидим:
`127.0.0.1 - - [20/Nov/2024 01:44:34] "GET / HTTP/1.1" 200 -`

Завершать исполнение можно по комбинации клавиш `Ctrl+C` в терминале.

> В данном коде для примера я использую `HTTPServer` открытый на `7654` порту на `localhost`. Его задача - отвечать на GET запросы отдавая ответ `200(ОК)` и данные в текстовом формате `text/html`.

Изменим немного наш проект.

`$ touch server.py`

Новое содержимое для файлов:

`server.py`

```
from http.server import BaseHTTPRequestHandler, HTTPServer


def run(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler):
    server_address = ("", 7654)
    httpd = server_class(server_address, WeatherHandler)
    httpd.serve_forever()


class WeatherHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        return self.render(200, b"Hello World!")

    def render(self, response_code: int, response_body: bytes | None = None):
        self.send_response(response_code)
        if response_body is not None:
            self.send_header("Content-type", "text/html")
        self.end_headers()
        if response_body is not None:
            self.wfile.write(response_body)
```

`main.py`

```
from server import run

run()
```

Исполним `$ python3 main.py`

Видим в браузере что результат выполнения такой-же каким и был до этого.

> В данном случае мы удалили из main.py весь излишний код, который там был и вынесли его в отдельный файл.

Изменим `server.py`

```
from http.server import BaseHTTPRequestHandler, HTTPServer
from datetime import datetime


def run(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler):
    server_address = ("", 7654)
    httpd = server_class(server_address, WeatherHandler)
    httpd.serve_forever()


class WeatherHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        return self.data_output()

    def data_output(self):
        date = bytes(datetime.today().strftime("%Y-%m-%d %H").encode("UTF-8"))
        return self.render(200, date)

    def render(self, response_code: int, response_body: bytes | None = None):
        self.send_response(response_code)
        if response_body is not None:
            self.send_header("Content-type", "text/html")
        self.end_headers()
        if response_body is not None:
            self.wfile.write(response_body)

```

`$ python3 main.py`

Теперь в браузере нам возвращается текущая дата и время в часах, это ещё пригодится в дальнейшей работе.

Изменим `server.py`

```
from http.server import BaseHTTPRequestHandler, HTTPServer
from datetime import datetime
import urllib.request


def run(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler):
    server_address = ("", 7654)
    httpd = server_class(server_address, WeatherHandler)
    httpd.serve_forever()


class WeatherHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        return self.data_output()

    def data_output(self):
        date = datetime.today().strftime("%Y-%m-%d %H")
        raw_data = weather_handler(date)
        return self.render(200, raw_data)

    def render(self, response_code: int, response_body: dict | None = None):
        self.send_response(response_code)
        if response_body is not None:
            self.send_header("Content-type", "application/json")
        self.end_headers()
        if response_body is not None:
            self.wfile.write(response_body)


def weather_handler(date: str) -> dict:
    url = "https://api.open-meteo.com/v1/forecast?latitude=48.712&longitude=44.514&current=temperature_2m,precipitation_probability,relative_humidity_2m,rain,snowfall,weather_code,wind_speed_10m,wind_direction_10m&hourly=temperature_2m,precipitation_probability,relative_humidity_2m,rain,snowfall,weather_code,wind_speed_10m,wind_direction_10m&timezone=Europe/Moscow&forecast_days=1"
    raw_data = urllib.request.urlopen(url, timeout=10).read()
    return raw_data
```

Так писать не очень красиво, но дальше сделаем красивее.

`$ python3 main.py`

<blockquote>

Если вы в браузере всё ещё смотрите в окно сети, то можно обратить внимание, что обновление страницы занимает примерно 300-1000 мс.

Это происходит из-за того, что каждый раз обновляя страницу, мы вынуждены обращаться к удалённому серверу, чтобы получить данные.

> В целях предотвращения ситуаций DDOS сервера обеспечивающие такие данные, обычно дают выполнить в течении дня не более чем определённое количество запросов.

> Так как мы запрашиваем данные о погоде, которые как правило не обновляются с большой скоростью, тут нам и понадобится дата с часом, которую мы вводили в код ранее.

</blockquote>

Текущая версия программы выдаёт данные о погоде на сегодняшний день в текущий момент, и на ближайшие 24 часа в формате json.

Изменим `server.py`

```
from http.server import BaseHTTPRequestHandler, HTTPServer
from datetime import datetime
import urllib.request
from functools import cache


def run(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler):
    server_address = ("", 7654)
    httpd = server_class(server_address, WeatherHandler)
    httpd.serve_forever()


class WeatherHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        return self.data_output()

    def data_output(self):
        date = datetime.today().strftime("%Y-%m-%d %H")
        raw_data = weather_handler(date)
        return self.render(200, raw_data)

    def render(self, response_code: int, response_body: dict | None = None):
        self.send_response(response_code)
        if response_body is not None:
            self.send_header("Content-type", "application/json")
        self.end_headers()
        if response_body is not None:
            self.wfile.write(response_body)


@cache
def weather_handler(date: str) -> dict:
    url = "https://api.open-meteo.com/v1/forecast?latitude=48.712&longitude=44.514&current=temperature_2m,precipitation_probability,relative_humidity_2m,rain,snowfall,weather_code,wind_speed_10m,wind_direction_10m&hourly=temperature_2m,precipitation_probability,relative_humidity_2m,rain,snowfall,weather_code,wind_speed_10m,wind_direction_10m&timezone=Europe/Moscow&forecast_days=1"
    raw_data = urllib.request.urlopen(url, timeout=10).read()
    return raw_data
```

`$ python3 main.py`

Теперь первый запрос также займёт длительное время, но все запросы в течении часа будут обращаться к ранее полученным данным, из-за чего задержка снизится, а внешнего запроса в сеть не будет вовсе.

Время частично улучшить читаемость кода.

`$ touch weather.py`

Изменим `weather.py`

```
from functools import cache
import urllib.request


@cache
def weather_handler(date: str) -> dict:
    api_link = "https://api.open-meteo.com/v1/forecast?"
    coordinates = [48.712, 44.514]
    weather_values = "temperature_2m,precipitation_probability,relative_humidity_2m,rain,snowfall,weather_code,wind_speed_10m,wind_direction_10m"
    timezone = "Europe/Moscow"
    days = "1"
    url = (
        api_link
        + "latitude="
        + str(coordinates[0])
        + "&longitude="
        + str(coordinates[1])
        + "&current="
        + weather_values
        + "&hourly="
        + weather_values
        + "&timezone="
        + timezone
        + "&forecast_days="
        + days
    )
    raw_data = urllib.request.urlopen(url, timeout=10).read()
    return raw_data
```

Изменим `server.py`

```
from http.server import BaseHTTPRequestHandler, HTTPServer
from datetime import datetime
from weather import weather_handler


def run(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler):
    server_address = ("", 7654)
    httpd = server_class(server_address, WeatherHandler)
    httpd.serve_forever()


class WeatherHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        return self.data_output()

    def data_output(self):
        date = datetime.today().strftime("%Y-%m-%d %H")
        raw_data = weather_handler(date)
        return self.render(200, raw_data)

    def render(self, response_code: int, response_body: dict | None = None):
        self.send_response(response_code)
        if response_body is not None:
            self.send_header("Content-type", "application/json")
        self.end_headers()
        if response_body is not None:
            self.wfile.write(response_body)
```

`$ python3 main.py`

В данном случае ничего в исполнении не изменилось, так как мы просто изменили внешний вид кода, не меняя сути.

Остаётся сделать демона и поставить его в нужную директорию

`$ touch fix.py`

`$ cd ..`

`$ mkdir services`

`$ cd services`

`$ touch weather.service`

`$ cd ..`

`$ chmod +x main.sh`

Изменим `main.sh`

```
#!/bin/bash
SCRIPT=$(readlink -f "$0")
DIR=$(dirname "$SCRIPT")

cd $DIR
python3 src/fix.py
ln -f services/weather.service $HOME/.config/systemd/user/weather.service

systemctl --user daemon-reload
/usr/bin/systemctl --user start weather.service

```

Изменим `fix.py`

```
import os
from pathlib import Path


def fix():
    projectDir = Path(__file__).resolve().parent.parent
    with open(os.path.join(projectDir, "services/weather.service"), "r") as service:
        lines = service.readlines()
    lines[5] = "ExecStart=python3 " + os.path.join(projectDir, "src/main.py") + "\n"
    with open(os.path.join(projectDir, "services/weather.service"), "w") as service:
        service.writelines(lines)


fix()
```

Изменим `weather.service`

```
[Unit]
Description=Weather collection service

[Service]
Type=simple
ExecStart=python3 /home/citrullux/ProjectOS/src/main.py
Restart=always

[Install]
WantedBy=default.target
```

`$ ./main.sh`

И да, теперь наш питоновский скрипт забирающий показания погоды за день работает как демон. Можно выполнить команду:

`/usr/bin/systemctl --user enable weather.service`

И он будет автоматически запускаться.

## Индивидуальное задание

Задания распределяются по вариантам от 0 до 9 в зависимости от последней цифры в номере вашей зачётной книжки.

### Вариант 1/6
___

Требуется разработать python приложение с HTTP сервером, которое будет выдавать содержимое дирректории передаваемой в GET запросе.

К примеру `http://localhost:7654/?%2Fhome%2Fusername`

Отдаст содержимое папки `/home/username`

В случае, если дирректории не существует, в браузер должен отдаваться статус 422 и пустая страница.

В случае если к директории нет доступа нужно отдать ответ отданный в консоль командой `ls` по заданой директории.

### Вариант 2/7
___

Требуется разработать python приложение с HTTP сервером, которое будет выдавать содержимое выполненний команды передаваемой в GET запросе.

К примеру `http://localhost:7654/?lscpu`

Отдаст результат выполнения команды `lscpu`

Если команда требует повышения прав до `sudo` требуется отдать статус 422 и пустую страницу.

### Вариант 3/8
___
Требуется разработать python приложение с HTTP сервером, которое будет выдавать погоду в соответствии с координатами передаваемыми в GET запросе.

К примеру `http://localhost:7654/?longttude=88.7&latitude=48.7`

Отдаст погоду на соответствующих координатах.

Если координат не существует, требуется отдать статус 422 и пустую страницу.


### Вариант 4/9
___
Требуется разработать python приложение с HTTP сервером, которое будет выдавать погоду в соответствии с датой передаваемой в GET запросе.

К примеру `http://localhost:7654/?date=22%2F12%2F2024`

Отдаст погоду за дату 22 декабря 2024 года.

Если дата не существует или находится в будущем, требуется отдать статус 422 и пустую страницу.


### Вариант 5/0
___
Требуется разработать python приложение с HTTP сервером, которое будет выдавать данные о курсе валют относительно рубля в соответствии с датой передаваемой в GET запросе.

К примеру `http://localhost:7654/?date=22%2F12%2F2024`

Отдаст курсы валют за дату 22 декабря 2024 года.

Если координат не существует, требуется отдать статус 422 и пустую страницу.

