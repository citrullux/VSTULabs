# Лабораторная работа: Использование системных инструментов и языка высокого уровня

Лабораторная на доработке, будет посвящена работе над проектом, представленным по ссылке ниже:

__[Текущая версия проекта для скачивания](https://cluster.vstu.ru/git/citrullux/ModernOSWeather)__

Задания в данной работе идут между текстом глав для лучшего понимания контекста приводимой теоретической базы. Они помечаются как

>Задание:

## Введение

С момента основания компьютерной индустрии под взаимодействием пользователей с электронно вычислительной машиной (далее ЭВМ) понимается использование устройств предназначенных для __ввода__ с целью получения от неё какого либо __вывода__ через соответствующие устройства.

Если говорить более простым языком:

> Пользователь что-то подаёт ожидая какой-либо реакции на свои действия

К примеру, если мы печатаем текст в текстовом редакторе навроде Google Docs, мы ожидаем что каждый вводимый нами символ с клавиатуры будет отображаться в документе после его введения. При помощи мыши мы будем иметь возможность выделения частей текста для выполнения иных действий, таких как выжеления текста __жирным__, _курсивом_ или добавление <font color="#AAAAFF">иных</font> элементов и эффектов на страницу. При этом результат наших действий мы оцениваем при помощи экрана.

Данное описание применимо буквально для любого класса устройств, будь то наиболее распространённый вид ЭВМ на планете на момент написания этого материала, смартфон, или даже VR шлем. Разница заключается только в том, что на смартфоне в качестве "мыши" будет использоваться ввод через сенсорный экран, а в VR шлеме контроллеры или даже пальцы рук, которые современные шлемы умеют обнаруживать.

Клавиатура и экран как концепция в современных устройствах есть буквально везде. Если же у устройства их нет, то мы взаимодействуем с ними при помощи устройств у которых они есть. Если у вас когда-либо был робот пылесос, то скорее всего вы управляли им через ноутбук или смартфон у которых есть экран и клавиатура.

В экзотических сценариях в дополнение к уже перечисленным средствам могут использоваться иные устройства ввода, к примеру, мало кто использует клавиатуру для управления игрушечной машинкой, куда проще и точнее для этого использовать какой-либо контроллер.

> И на 4 абзаце этой стены текста возникает закономерный вопрос - __а при чём тут вообще курс _операционных систем_-то?__

## Глава 1 - Ввод/Вывод

Давайте ответим для себя на простой вопрос - вот когда мы вводим что-то с клавиатуры мы взаимодействуем с операционной системой?

Распространённый ответ на этот вопрос у студентов - ну конечно-же __да__, ведь вот на экране __операционныя система(ОС)__, будь то  Linux, Windows, macOS, Android, iOS _и дальше можно перечислять до бесконечности_, разве взаимодействие с ОС через экран, клавиатуру и другие устройства ввода не значит само по себе взаимодействие с ОС?

С какой-то стороны звучит такая позиция очень разумно. Но есть ньюанс.

__Вернёмся к первой аналогии__

Когда мы используем Google Docs чтобы редактировать документ, чем принципиально для нас, как пользователя, отличается взаимодействие с Google Docs на Windows, Linux, macOS и даже на Android и iOS?

> Мы везде используем __клавиатуру__, и некое __устройство ввода нажатий__ на область экрана чтобы редактировать текст и добавлять или удалять со страницы элементы.

И получается, что принципиальной разницы от изменения операционной системы мы как пользователь не получаем.

Ведь мы как пользователь работаем не с операционной системой, а с конкретным приложением, скорее всего Google Docs у вас открыт в браузере, который открыт на рабочем столе, <font color="#88CC88">_ну или поверх варианта X-org/Wayland сессии или чего бы то там ни было на macOS_</font>, который сам по себе тоже является приложением!

Так что же такое __операционная система__ и __что конкретно__ она в данном случае __делает?__

## Глава 2 - Идём от запуска

Вы никогда не задумывались что вообще происходит когда мы запускаем компьютер? Я не говорю о инициализации устройст BIOS или UEFI. Но после них начинает загружаться сама ОС.

Всё то время пока мы смотрим на красивое лого производителя данного компьютера если у нас UEFI или наслаждаемся красивым логотипом установленной операционной системы, ведь всё это время что-то происходит.

В целом администраторы которым нужно понимать что конкретно происходит с системой во время загрузки, либо смотрят в журнал ОС если она вообще запускается, либо включают отображение дампа загрузки вместо красивого графического отображения операционной системы.

В случае закрытых операционных систем мы точно не знаем что конкретно они делают, но в случае с Linux всё довольно очевидно.

> В глубину мы тут не полезем ибо оно особо не нужно нам на этом курсе...

Для понимание дальнейшего описания нужно понимать простую концепцию

__Linux__ это __не операционная система__.

__Linux__ это __ядро__. Вокруг которого операционная система может быть построена.

<blockquote>

Вы наверняка слышали про Android. В основе Android лежит ядро Linux, только вот весь софт который ядро окружает и конкретная Java машина сделаны компанией Google.

Существуют и другие оболочки, Ubuntu, Red Hat, GNU и прочее. Разница между этими операционными системами состоит в тех приложениях, которые доступны по умолчанию и особенностях взаимодействия с конкретной операционной системой.

Потосу обычно системы на Linux в профессиональной среде называются как __Android/Linux__ __Ubuntu/Linux__ и __GNU/Linux__.

Кстати, если бы Windows именовалась схожим образом то она должна была бы называться __Windows98/DOS__ __Windows11/NT__ а macOS - __MacOS/XNU__.

</blockquote>


Задача __загрузки ОС__ по-сути состоит в __запуске приложения__ с которым будет __взаимодействовать__ пользователь.

Для того чтобы приложение, с которым пользователь хочет взаимодействовать, могло работать как надо, оно должно иметь возможность получать данные с ввода и передавать данные на вывод.

И в целом мысль состоит бы в том что надо просто дать приложению возможность взаимодействовать с вводом и выводом как оно захочет, и всё будет хорошо.

> Но в данной концепции работы приложений есть определённая проблема.

## Глава 3 - Интерфейс программирования приложения (API)

![DOOM Configuration](./Images/setup.png)

Рисунок 1 - Окно конфигурации звука DOS

Перед вами окно конфигурации звука для DOS версии игры Doom, и это прямой пример того, что случается, когда мы оставляем взаимодействие с чем-либо на программу вместо того чтобы работать посредством операционной системы.

Проблема, которую обозначает этот рисунок заключается в том, что для поддержки вывода звука из игры нужно всего-лишь написать собственную реализацию кода взаимодействия для каждой конкретной звуковой карты.

И если реализация для конкреной звуковой карты не была написана разработчиком, то с такой звуковой картой звука вы из Doom на DOS получить не могли.

И надо понимать, что если каждый разработчик должен будет самостоятельно реализовывать поддержку всего оборудования, то больше времени он будет уделять написанию кода поддержки, нежели созданию самого приложения.

Потому в операционной системе есть такая вещь как API, по-сути это набор приложений и функций с которыми может взаимодействовать ваше приложение посредством некоторого интерфейса, а уже их задача как-либо взаимодействовать с оборудованием.

Если вы когда-нибудь наблидали на коробке видеокарты или любого другого оборудовая что оно совместимо с DirectX или OpenGL/OpenAL или Vulkan то вы видели прямое указание возможности взаимодействия с этими устройствами посредством данных API.

Но в целом DOS тоже был операционной системой, которая обеспечивала некоторые взаимодействия без вмешательства программиста.

К примеру работа с диском, возможность выводить звук на PC-speaker и изображение на экран, взаимодействие с клавиатурой были заложены в операционную систему как готовые API.

![IBM PC](./Images/ibmpc.jpg)

Рисунок 2 - IBM PC

Такой набор возможностей во многом обусловлен тем, чем являлся IBM PC на начале своего пусти - простым домашним компьютером с монитором, клавиатурой и PC-спикером для вывода звука.

Подводя итоги:

>__Операционная система__ - это набор приложений и  ядро, задача которых предоставление другим приложениям возможности работать с определённым оборудованием и взаимодействовать с другими приложениями и/или пользователем.

Если взять представленное определение - то работа с операционной системой с точки зрения как пользователя так и администратора состоит в использовании различных приложений в целях достижения определённых результатов.

И в целом, можно было бы прямо сейчас открыть Linux консоль и начать просто вводить какие-либо команды рассматривая что они делают, но это не так интересно. Нужно написать что-то интересное и нужное, но чтобы понимать что конкретно мы делаем и почему, нужно дать немного информации на примерах.

Давайте начнём с одной из основных концепций в Linux.

## Глава 4 - Работа с файловой системой

В целом довольно плохо начинать изучение файловой системы в Linux с приведения Windows в аналогию, но для большей понятности мы поступим именно так.

Да и возможно содержимое пункта 4.1 будет даже для вас некоторым новым материалом.

### 4.1 Понятный большинству подход и его "особенности"

Для тех кто работал с Windows и представляет файловую систему как что-то начинающееся с имени диска, к примеру, `C:` требуется понять что такая концепция характерна __только__ для Windows.

В Windows мы можем перейти с диска `C:` на диск `D:` просто вписав в консоль `D:` и если у нас есть диск с такой буквой, консоль переключится на другой диск.

![Drive switch](./Images/switch.png)

Рисунок 3 - Пример смены диска

Также переходя в диспетчер файлов в левой части окна мы можем видеть список наших дисков, что очень удобно. И те, кто пользовался Windows примерно всегда знают что а диске `C:` можно найти папки Windows, Program Files и Users, а остальное будет опционально.

Неизменным остаётся только один факт - все папки внутри диска `C:` должны находиться на __одном__  физическом диске ну или на массиве дисков объединённых в __один__ если мы имеем дело с RAID.

> Однако то что написано в прошлом абзаце - __неправда__

Механизм Windows действительно подразумевает создание нового диска при попытке подключения нового раздела или диска, однако если пойти в инструмент __управление компьютером__ и перейти в __управление дисками__ можно немного удивиться.

![Connect as folder](./Images/connect.png)

Рисунок 4 - Подключение диска как папки.

Да, можно просто подключить диск как папку на другом диске, и это даже будет работать. Однако изначальная папка, куда мы хотим смонтировать наш диск должна быть пустой.

А для Linux такой менанизм взаимодействия является __базовым__.

### 4.2 Файловая система в Linux, основы.

__"Всё есть файл."__ - это основная концепция ОС на базе ядра Linux.

В Linux со любым ресурсом который у вас есть можно взаимодействовать как с файлом, в том числе с устройствами.

В Linux всё начинается с корня - `/`

Корневая файловая система в Linux содержит в себе все файлы операционной системы, из корня можно перейти в каждую дирректорию и файл.

В базовой комплектации в дирректории `/` содержатся следующие поддирректории:

```
/bin /dev /home /media /proc /sbin /sys /var /boot /etc /lib /mnt /root /tmp /lib64 /opt /run /usr
```

Если в Windows чтобы посмотреть на имеющиеся устройства мы должны пойти в диспетчер устройств, то в Linux можно просто перейти в дирректорию `/dev` и увидеть все устройства которые система обнаружила в виде файлов.

Из этих файлов можно считывать информацию, а также можно попытаться в них что-то записывать.

> Автор данного материала крайне __не рекомендует__ что-либо записывать в файлы устройств, все возможные наносимые __повреждения__ операционной системе от использования _sudo_ или _root_ в результате таких действий остаются на __ответственности пользователя__.

В пункте 4.1 я приводил некоторые папки Windows, их очень примерными аналогами в Linux являются:

`C:/Users -> /home`

```
C:/ProgramFiles ->
/bin /sbin
/usr/bin /usr/sbin
/opt
```

`C:/Windows -> /sys`

Но всё это очень примерно, так как подходы операционных систем отчичаются, и значимо. Это скорее приведено чтобы знать где примерно искать.

